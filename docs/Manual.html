<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>libSps - Manual &mdash; libSps 0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Documentation for the Python Module" href="Python.html" />
    <link rel="prev" title="libSps - The Sparse Prefix Sums Library" href="Readme.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> libSps
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Readme.html">libSps - The Sparse Prefix Sums Library</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">libSps - Manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bioconda">BioConda</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-compilation-parameters">Default Compilation Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#github-cmake">GitHub/CMake</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#python">Python</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-indices">Creating indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#querying-indices">Querying indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#documentation">Documentation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c">C++</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Creating indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Querying indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">Documentation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dependent-dimensions">Dependent Dimensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#intervals">Intervals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#format-specification">Format specification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default-sizes">Default sizes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#limitations">Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#thanks">Thanks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#citing-libsps">Citing libSps</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Python.html">Documentation for the Python Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Cpp.html">Documentation for the C++ Library</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">libSps</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>libSps - Manual</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Manual.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="libsps-manual">
<h1>libSps - Manual<a class="headerlink" href="#libsps-manual" title="Permalink to this headline"></a></h1>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline"></a></h2>
<p>There are two ways to install libSps: Via bioconda and via GitHub/CMake.
The bioconda installation is easier, but restricts you to using the default compilation parameters (see below).</p>
<section id="bioconda">
<h3>BioConda<a class="headerlink" href="#bioconda" title="Permalink to this headline"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="o">-</span><span class="n">c</span> <span class="n">bioconda</span> <span class="n">install</span> <span class="n">libSps</span>
</pre></div>
</div>
</section>
<section id="default-compilation-parameters">
<h3>Default Compilation Parameters<a class="headerlink" href="#default-compilation-parameters" title="Permalink to this headline"></a></h3>
<p>By default libSps is compiled to handle the following types of data:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Dimensions</p></td>
<td><p>2 and 3 dimensional</p></td>
</tr>
<tr class="row-odd"><td><p>Dependent dimension</p></td>
<td><p>off</p></td>
</tr>
<tr class="row-even"><td><p>Intervals / Rectangles / Cubes</p></td>
<td><p>off</p></td>
</tr>
<tr class="row-odd"><td><p>Storage type</p></td>
<td><p>main memory and cached</p></td>
</tr>
</tbody>
</table>
<p>Note that these parameters can be changed using the GitHub/CMake installation method.</p>
</section>
<section id="github-cmake">
<h3>GitHub/CMake<a class="headerlink" href="#github-cmake" title="Permalink to this headline"></a></h3>
<p>To compile libSps from the githug source use the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># clone repository</span>
<span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">MarkusRainerSchmidt</span><span class="o">/</span><span class="n">libSps</span>
<span class="n">cd</span> <span class="n">libSps</span>

<span class="c1"># create and activate conda environment (alternativeley, install the packages in conda_env/libSps.yaml yourself)</span>
<span class="o">./</span><span class="n">conda_env</span><span class="o">/</span><span class="n">create_env</span><span class="o">.</span><span class="n">sh</span>
<span class="n">conda</span> <span class="n">activate</span> <span class="n">libSps</span>

<span class="c1"># configure build</span>
<span class="n">mkdir</span> <span class="n">build</span>
<span class="n">cd</span> <span class="n">build</span>
<span class="n">cmake</span> <span class="o">../</span><span class="n">libSps</span><span class="o">/</span> <span class="c1"># Here you can configure various options (see below)</span>

<span class="c1"># build</span>
<span class="n">make</span>
</pre></div>
</div>
<p>Various parameters of libSps are set during compile time.
We chose to use compile time parameters as the underlying memory layout is affected and as this improves runtime performance.
If you plan using libSps from C++ you can set all these options via template parameters (see “Creating indices” below).
However, for python you have to define the parameters at compile time.
With CMake, you can configure libSps in various ways:</p>
<p>Add <code class="docutils literal notranslate"><span class="pre">-DWITH_PYTHON=ON</span></code> to create a shared object file that can be imported as a python module. If this parameter is set:</p>
<ul class="simple">
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DNUM_DIMENSIONS_A=X</span> <span class="pre">-DNUM_DIMENSIONS_B=Y</span> <span class="pre">...</span> <span class="pre">-DNUM_DIMENSIONS_D=Z</span></code> to create indices with X, Y, …, Z dimensions.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DW_DEPENDENT_DIM=ON</span></code> to create indices where dimension 1 of the overlay grid is dependent on its dimension 0.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DWO_DEPENDENT_DIM=ON</span></code> to create indices where the overlay grids’ dimensions are independent of each other.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DW_CUBES=ON</span></code> to create indices where entries are not point-like but interval-like on the first 3 dimensions. I.e. cubes placed in &gt;=3-dimensional space.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DW_RECTANGLES=ON</span></code> to create indices where entries are not point-like but interval-like on the first 2 dimensions. I.e. rectangles placed in &gt;=2-dimensional space.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DW_INTERVALS=ON</span></code> to create indices where entries are not point-like but interval-like on the first dimension. I.e. intervals placed in n-dimensional space.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DW_POINTS=ON</span></code> to create indices where entries are fully point-like.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DDISK=ON</span></code> to create indices that load all data from a file on startup and store it back to the file on shutdown. Expect them to consume as much RAM as the filesize.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DCACHED=ON</span></code> to create indices that use a cache to load data from and store data to a file dynamically as needed during runtime. Expect this storage type to be slightly slower than the other two options. For large datasets this storage is necessary, as it allows the RAM usage to be independent of the amount of data stored.</p></li>
<li><p>set <code class="docutils literal notranslate"><span class="pre">-DRAM=ON</span></code> to create indices that store all information in RAM and never interact with the filesystem.</p></li>
</ul>
<p>If multiple contradicting options are turned on as e.g. <code class="docutils literal notranslate"><span class="pre">-DNUM_DIMENSIONS_A=7</span> <span class="pre">-DNUM_DIMENSIONS_B=3</span></code> and <code class="docutils literal notranslate"><span class="pre">-DRAM=ON</span> <span class="pre">-DDISK=ON</span></code> indices with all valid combinations will be compiled and made available via the <code class="docutils literal notranslate"><span class="pre">make_sps_index()</span></code> factory function.
You may want to consider turning options off to save compiletime: E.g. <code class="docutils literal notranslate"><span class="pre">-DCACHED=OFF</span> <span class="pre">-DNUM_DIMENSIONS_A=0</span></code>.</p>
</section>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline"></a></h2>
<p>The libSps workflow is seperated in two phases: Creating an index and querying the index.</p>
<section id="python">
<h3>Python<a class="headerlink" href="#python" title="Permalink to this headline"></a></h3>
<p>This section contains the documentation for using libSps from Python3.</p>
<section id="creating-indices">
<h4>Creating indices<a class="headerlink" href="#creating-indices" title="Permalink to this headline"></a></h4>
<p>First you need to pick the correct implementation of the sparse prefix sum index for your use-case.
For this, it is easiest to call the <code class="docutils literal notranslate"><span class="pre">make_sps_index</span></code> factory function with the appropriate parameters.</p>
<p>For example creating an Index for 4-dimensional points, that</p>
<ul class="simple">
<li><p>can deal with a large amount of points, and</p></li>
<li><p>saves all data in files using a cache.</p></li>
</ul>
<p>use the following parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">make_sps_index</span><span class="p">(</span><span class="s2">&quot;example_index_prefix&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">storage_type</span><span class="o">=</span><span class="s2">&quot;Cached&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If instead of points, you want to query intervals, rectangles, cubes or orthotopes of higher dimensionality, adjust the num_orthotope_dimensions parameter.
Note that e.g. rectangles can still be placed in more than 2-dimensional space.
For example rectangles that are placed in 3-dimensional space will extend in the first two dimensions and be completely flat in the third.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Rectangles in 3-dimensional space</span>
<span class="n">index_2</span> <span class="o">=</span> <span class="n">make_sps_index</span><span class="p">(</span><span class="s2">&quot;example_index_prefix_2&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">num_orthotope_dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Next you need to fill the index with points.
At the moment a description for each point can be stored but not retrieved again (hence you can also just leave the description empty).
The number of coordinates you provide for each point must match the dimensionality of the index you picked in step 1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span><span class="o">.</span><span class="n">add_point</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="s2">&quot;description of point for index&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If your index contains orthotope dimensions (see Manual-&gt;Usage-&gt;Intervals) adding one datapoint requires its bottom-left-front-… point and its top-right-back-… point.
Again the dimensionality of the given points must match the picked number of dimensions.
For dimensions that are not orthotope the coordinates of both given points must be equal.</p>
<p>For example in index_2 the third dimension is not part of the rectangle and hence equal (in this case: 1) for both points.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index_2</span><span class="o">.</span><span class="n">add_point</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;description of point for index_2&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once all points have been added you call <code class="docutils literal notranslate"><span class="pre">generate</span></code> to create the sparse prefix sum matrix.
This may take a long time to compute.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dataset_id</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
</pre></div>
</div>
<p>Generate returns the id of the generated dataset.
You will need this id for querying the index later.</p>
<p>If you want to store multiple datsets in the same index you can provide the generate function with the index of the first point that shall be part of the dataset and the index of one past the last point that shall be part of the dataset.
Note that if your index is orthotope a single datapoint may take up multiple indices.
You should hence use <code class="docutils literal notranslate"><span class="pre">len(index)</span></code> for determining the start and end indices of your datasets before and after adding points.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">make_sps_index</span><span class="p">()</span>

<span class="c1"># create dataset a</span>
<span class="n">start_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="n">index</span><span class="o">.</span><span class="n">add_point</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">index</span><span class="o">.</span><span class="n">add_point</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">end_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="n">dataset_a_id</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">start_a</span><span class="p">,</span> <span class="n">end_a</span><span class="p">)</span>

<span class="c1"># create dataset b</span>
<span class="n">start_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="n">index</span><span class="o">.</span><span class="n">add_point</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">index</span><span class="o">.</span><span class="n">add_point</span><span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">end_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="n">dataset_b_id</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">start_b</span><span class="p">,</span> <span class="n">end_b</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="querying-indices">
<h4>Querying indices<a class="headerlink" href="#querying-indices" title="Permalink to this headline"></a></h4>
<p>For querying indices you provide the bottom-left-front-…. position and the top-right-back-… position of the region you want to count the number of points in. You also need the id of your dataset you got while calling generate.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">dataset_a_id</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
</pre></div>
</div>
<p>The bottom-left-front-…. position is inclusive and the top-right-back-… position is exclusive.</p>
</section>
<section id="documentation">
<h4>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline"></a></h4>
<p>Technical Documentation for the python module can be found <span class="raw-html-md"><a href="https://github.com/MarkusRainerSchmidt/libSps/docs/Python.html" title="Python Documentation">here</a></span>.</p>
</section>
</section>
<section id="c">
<h3>C++<a class="headerlink" href="#c" title="Permalink to this headline"></a></h3>
<p>This section contains the Documentation for using libSps from C++17.
The C++ library is header-only, so you merely need to include the appropriate header files to get it working.</p>
<p>&#64;todo make a small example project that includes libSps
&#64;todo give example code for the vec generator and sorter</p>
<section id="id1">
<h4>Creating indices<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h4>
<p>For creating an instance of the Index class you need to provide the <code class="docutils literal notranslate"><span class="pre">type_defs</span></code> template parameter.
As this parameter you should provide an instance of the <code class="docutils literal notranslate"><span class="pre">TypeDefs</span></code> class.
You can either instantiate this class by itself or use the more convenient <code class="docutils literal notranslate"><span class="pre">InMemTypeDef</span></code>, <code class="docutils literal notranslate"><span class="pre">CachedTypeDef</span></code> or <code class="docutils literal notranslate"><span class="pre">DiskTypeDef</span></code>, which are defined in sps/default.h.</p>
<p>Here is an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;sps/default.h&quot;</span>
<span class="c1">#include &quot;sps/index.h&quot;</span>

<span class="n">typename</span> <span class="n">sps</span><span class="p">::</span><span class="n">Index</span><span class="o">&lt;</span><span class="n">InMemTypeDef</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">true</span><span class="o">&gt;&gt;</span> <span class="n">xIndex</span><span class="p">(</span> <span class="p">);</span>
</pre></div>
</div>
<p>Functionally, this does the same as the python <code class="docutils literal notranslate"><span class="pre">make_sps_index</span></code> factory function.</p>
<p>Then cou can call <code class="docutils literal notranslate"><span class="pre">addPoint</span></code> and <code class="docutils literal notranslate"><span class="pre">generate</span></code> to set up your datasets as needed.</p>
</section>
<section id="id2">
<h4>Querying indices<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h4>
<p>Querying indices works the same as for the python Module.</p>
</section>
<section id="id3">
<h4>Documentation<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h4>
<p>Technical Documentation for the c++ library can be found <span class="raw-html-md"><a href="https://github.com/MarkusRainerSchmidt/libSps/docs/Cpp.html" title="C++ Documentation">here</a></span>.</p>
</section>
</section>
<section id="dependent-dimensions">
<h3>Dependent Dimensions<a class="headerlink" href="#dependent-dimensions" title="Permalink to this headline"></a></h3>
<p>libSps can distribute overlays in dimension 1 dependent on dimension 0.</p>
<img src="../_static/distributing-overlays.png" /><p><em>Making dimension 1 dependent on dimension 0 breaks the uniform grid. Instread, rows are placed differently in each column.</em></p>
<p><strong>What are overlays?:</strong>
Overlays are used to reduce storage requirements in sparse prefix sum datastructures.
To achieve this, they span in a grid across the entire dataset.
For this to work best, points should be evenly distributed amongst the overlays.</p>
<p><strong>What does making one dimension dependent on another do?:</strong>
Usually the overlay grid is created, so that overlays are larger in regions where points are sparse and smaller in dense regions.
This is done independently for each dimension, i.e. by sorting all points by their position in this dimension and then creating a grid division after a fixed number of points.
If dimension 1 is dependent on dimension 0, these divisions for dimension 1 are not created globally, but locally for each slice of dimension 0.
This breaks the grid in this dimension, i.e. divisions will be placed at different heights for each slice.</p>
<p><strong>When is this usefull?:</strong>
This is usefull if your dataset looks evenly distributed, when looking at every dimension individually, but is strongly clustered when considering the first two dimensions together.
In this case the usual approach of stretching the grid will fail to separate points evenly among all overlays and therefore produce an extremely bloated datastructure.</p>
<p>One example for such data is Hi-C data, where most points (&gt;90%) lie close to the 45-degree diagonal.
Looking seperatately at dimesion 1 or 2, all points look like they are evenly distributed, while actually they are not.</p>
<p>For more details you should read Shekelyan et al. [1] and Schmidt et al. [2] or have a look at the <span class="raw-html-md"><a href="https://github.com/MarkusRainerSchmidt/smoother/docs/index.html" title="Go to the Smoother GitHub page.">documentation of Smoother</a></span>.</p>
</section>
<section id="intervals">
<h3>Intervals<a class="headerlink" href="#intervals" title="Permalink to this headline"></a></h3>
<p>libSps can be used to store and count n-dimensional orthotopes.
1, 2, 3, … dimensional orthotopes are intervals, rectangles, cubes, … .
libSps is able to place an n-orthotope in m-dimensional space (m&gt;=n), where the orthotope is simply a flat plane in the last m-n dimensions.</p>
<p><code class="docutils literal notranslate"><span class="pre">count</span></code> will only return orthotopes that are fully contained in the given region.</p>
<p>In order count orthotopes, libSps will store the prefix sums of the orthotopes corners seperately.
I.e. (assuming we store rectangles) for each position there will be a prefix sum for the bottom-left, bottom-right, top-left, and top-right corners of the stored rectangles.
While querying in a given rectangle, we can then use one of these 4 values in each corner of the queried rectangle to only count the stored rectangles that are fully within the queried rectangle.
This does work if and only if there is no stored rectangle that fully encloses the queried rectangle.
For being able to work with arbitrary data libSps hence adds one “helper”-dimension for each orthotope dimension, where orthrotopes are placed according to their size in the respective orthotope dimension.
While querying we can then use this helper-dimension to exclude rectangles that are big enough to enclose the queried area.
It is always fine to exclude all rectangles that are big enough to enclose the queried area from the get-go, since these rectangles are too large to be fully contained by the queried area and therefore never need to be counted.</p>
<p>For more details you should read Schmidt et al. [2].</p>
</section>
<section id="format-specification">
<h3>Format specification<a class="headerlink" href="#format-specification" title="Permalink to this headline"></a></h3>
<p>libSps can store indices on disk permanentely.
To achieve this, several files are created.
All these files are essentially vectors of varying length, where the individual elements are objects with sizes depending on the template parameters of the used type_defs (c++) or parameters of the make_sps_index function (Python).
These object sizes are not checked at runtime, so it is up to you, to ensure that the files created by an index with parameter set X,
are always opened with this parameter set X.
Merely the storage type (i.e. Cached or Disk) can be changed for each open operation.</p>
<p>In the following, we will list the objects stored in each index.
The size of the vectors is not stored and needs to be inferred from the file size and object size. in the following td::… referst to one of these template parameters.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>file</p></th>
<th class="head"><p>object</p></th>
<th class="head"><p>desc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>.desc</p></td>
<td><p>char</p></td>
<td><p>The description strings of all points. Each description is EOF terminated. Hence, points only need to store pointers to the start of their description. Strings are stored as individual characters (1 byte a piece).</p></td>
</tr>
<tr class="row-odd"><td><p>.points</p></td>
<td><p><strong>point</strong></p></td>
<td><p>The individual points that were added. Contains the points of all datasets. The order of points may not reflect the order they have been added in.</p></td>
</tr>
<tr class="row-even"><td><p>.prefix_sums</p></td>
<td><p><strong>prefix_sum_array</strong></p></td>
<td><p>The prefix sum for one position in space.</p></td>
</tr>
<tr class="row-odd"><td><p>.coords</p></td>
<td><p><strong>sparse_coordinate</strong></p></td>
<td><p>The translation from real to sparse coordinates. Each object is of type td::coordinate_t.</p></td>
</tr>
<tr class="row-even"><td><p>.overlays</p></td>
<td><p><strong>overlay</strong></p></td>
<td><p>The overlay grid.</p></td>
</tr>
<tr class="row-odd"><td><p>.datasets</p></td>
<td><p><strong>dataset</strong></p></td>
<td><p>The individual datasets.</p></td>
</tr>
</tbody>
</table>
<p>A <strong>point</strong> is composed of:</p>
<ul class="simple">
<li><p>its position: a td::D sized array of values of type td::coordinate_t.</p></li>
<li><p>a pointer to it’s descritpion of type size_t.</p></li>
<li><p>if td::IS_ORTHOTOPE, each add_point call adds all corners of the described orthotope.  <span class="raw-html-md"><br /></span>
In this case each of the added points also stores a value of type uint8_t that indicates which corner it refers to.  <span class="raw-html-md"><br /></span>
Corers are counted binary-like, i.e. in inverse order and from start to end position.  <span class="raw-html-md"><br /></span>
E.g. for 3 dimensions (left-right, down-up, front-back): left-down-front (000), left-down-back (001), left-up-front (010), left-up-back (011), right-down-front (100), …  <span class="raw-html-md"><br /></span>
See the Intervals section for more details.</p></li>
</ul>
<p>A <strong>prefix_sum_array</strong> is composed of:</p>
<ul class="simple">
<li><p>2^td::ORTHOTOPE_DIMS many values of type td::val_t.  <span class="raw-html-md"><br /></span>
If there are orthotope dimensions, the prefix sums for all corners of the orthotopes are stored seperately.  <span class="raw-html-md"><br /></span>
See the Intervals section for more details.</p></li>
</ul>
<p>An <strong>overlay</strong> is composed of:</p>
<ul class="simple">
<li><p>td::D * (td::D - 1) many <strong>sparse_coordinate_vector_interval</strong> s.  <span class="raw-html-md"><br /></span>
These store the translation from real to sparse space for the overlay cells.  <span class="raw-html-md"><br /></span>
Each block of td::D - 1 intervals belongs to one dimension <em>n</em> of the overlay and stores the translation to sparse space for all other <em>n-1</em> dimensions.</p></li>
<li><p>td::D many <strong>sparse_coordinate_vector_interval</strong>.  <span class="raw-html-md"><br /></span>
These store the translation from real to sparse space, individually for each dimension, for prefix sums of points within this overlay.</p></li>
<li><p>td::D many <strong>prefix_sum_vector_interval</strong> s, where N = td::D - 1.  <span class="raw-html-md"><br /></span>
These store the overlay cells’ prefix sums for each dimension <em>n</em> of the overlay.</p></li>
<li><p>one <strong>prefix_sum_vector_interval</strong>, where N = td::D.  <span class="raw-html-md"><br /></span>
Stores the prefix sums for the points that belong to this overlay.</p></li>
<li><p>one <strong>point_vector_interval</strong>.  <span class="raw-html-md"><br /></span>
Stores the points that belong to this overlay.</p></li>
</ul>
<p>A <strong>sparse_coordinate_vector_interval</strong> is composed of:</p>
<ul class="simple">
<li><p>index of type td::coordinate_t.</p></li>
<li><p>start of type td::coordinate_t.</p></li>
<li><p>end of type td::coordinate_t.</p></li>
</ul>
<p>Here start and end give the coordinates of the interval in real space that is mapped to sparse space.
Index gives the start index of the interval in .coords.
The size of the interval is end-start.
To map a coordinate X from real to sparse space one has to lookup the value in .coords at position index+X-start.</p>
<p>A <strong>prefix_sum_vector_interval</strong>, with a given N, is composed of:</p>
<ul class="simple">
<li><p>N many axis sizes of type td::coordinate_t.</p></li>
<li><p>index of type td::coordinate_t.</p></li>
</ul>
<p>Axis sizes give the size of each dimension of an N-dimensional grid.
the index i of a point p is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="k">for</span> <span class="n">n</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">N</span><span class="p">:</span>
    <span class="nb">set</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">axis_size</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<p>Index gives the start index of the interval in .prefix_sums.</p>
<p>A <strong>point_vector_interval</strong> is composed of:</p>
<ul class="simple">
<li><p>a start index of type td::coordinate_t.  <span class="raw-html-md"><br /></span>
Points to the first point in .points of this interval.</p></li>
<li><p>a end index of type td::coordinate_t.  <span class="raw-html-md"><br /></span>
Points to one past the last point in .points of this interval.</p></li>
</ul>
<p>A <strong>dataset</strong> is composed of:</p>
<ul class="simple">
<li><p>td::D many <strong>sparse_coordinate_vector_interval</strong>.  <span class="raw-html-md"><br /></span>
These store the translation from real to sparse space, individually for each dimension, for the overlays of this dataset.</p></li>
<li><p>one <strong>sparse_coordinate_vector_interval_array</strong>.  <span class="raw-html-md"><br /></span>
Stores the sparse coordinates of dimension 2 in case this dimension is dependent on dimension 1.  <span class="raw-html-md"><br /></span>
Otherwise this object may be uninitialized.</p></li>
<li><p>one <strong>overlay_vector_interval</strong>, where N = td::D.</p></li>
</ul>
<p>A <strong>sparse_coordinate_vector_interval_array</strong> is composed of:</p>
<ul class="simple">
<li><p>index of type td::coordinate_t.</p></li>
<li><p>start of type td::coordinate_t.</p></li>
<li><p>end of type td::coordinate_t.</p></li>
<li><p>amount of type td::coordinate_t.</p></li>
</ul>
<p>Works the same as sparse_coordinate_vector_interval, expect for storing amount many coordinate translations.
All stored coordinate translation must have the same start and end indices.
Further, they need to be consecutive in .coords.</p>
<p>A <strong>overlay_vector_interval</strong>, with a given N, is composed of:</p>
<ul class="simple">
<li><p>N many axis sizes of type td::coordinate_t.</p></li>
<li><p>index of type td::coordinate_t.</p></li>
</ul>
<p>Axis sizes give the size of each dimension of an N-dimensional grid.
the index i of a point p is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="k">for</span> <span class="n">n</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">N</span><span class="p">:</span>
    <span class="nb">set</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">axis_size</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<p>Index gives the start index of the interval in .overlays.</p>
<section id="default-sizes">
<h4>Default sizes<a class="headerlink" href="#default-sizes" title="Permalink to this headline"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>type</p></th>
<th class="head"><p>default size in bytes</p></th>
<th class="head"><p>desc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>td::D</p></td>
<td><p>n/a</p></td>
<td><p>Number of dimensions. Note: Making one dimension orthotope always also adds a non orthotope dimension to the index. These extra dimensions are also included in td::D</p></td>
</tr>
<tr class="row-odd"><td><p>td::coordinate_t</p></td>
<td><p>4 bytes (uint32_t)</p></td>
<td><p>An individual coordinate of a point.</p></td>
</tr>
<tr class="row-even"><td><p>td::ORTHOTOPE_DIMS</p></td>
<td><p>n/a</p></td>
<td><p>Number of orthotope dimensions. Note: Making one dimension orthotope always also adds a non orthotope dimension to the index. These extra dimensions are also included in td::D</p></td>
</tr>
<tr class="row-odd"><td><p>td::val_t</p></td>
<td><p>4 bytes (uint32_t)</p></td>
<td><p>A single prefix sum.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>libSps does not work with negative coordinates.</p></li>
<li><p>dimension 1 is the only dimension that can be made dependent on another dimension and it can only be made dependent on dimension 0.</p></li>
</ul>
</section>
<section id="thanks">
<h2>Thanks<a class="headerlink" href="#thanks" title="Permalink to this headline"></a></h2>
<p>libSps uses several other projects. These are:</p>
<ul class="simple">
<li><p><span class="raw-html-md"><a href="https://github.com/pybind/pybind11" title="GitHub">Pybind11</a></span>: Seamless operability between C++11 and Python</p></li>
<li><p><span class="raw-html-md"><a href="https://github.com/stxxl/stxxl" title="GitHub">STXXL</a></span>: Standard Template Library for Extra Large Data Sets</p></li>
</ul>
</section>
<section id="citing-libsps">
<h2>Citing libSps<a class="headerlink" href="#citing-libsps" title="Permalink to this headline"></a></h2>
<p>For citing libSps, please use:
&#64;todo</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<p>[1] Shekelyan, M., Dignös, A. &amp; Gamper, J. Sparse prefix sums: Constant-time range sum queries over sparse multidimensional data cubes. Information Systems 82, 136–147 (2019).</p>
<p>[2] Schmidt et al. &#64;todo</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Readme.html" class="btn btn-neutral float-left" title="libSps - The Sparse Prefix Sums Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Python.html" class="btn btn-neutral float-right" title="Documentation for the Python Module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Markus Schmidt.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>